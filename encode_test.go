package kdb

import (
	"bytes"
	"time"
	"github.com/nu7hatch/gouuid"
	"testing"
)

var TimestampAsTime = time.Date(2018, 1, 26, 1, 49, 0, 884361000, time.UTC)

//q)-8!("ac";`b;`)
var GenericList2Bytes = []byte{0x01, 0x00, 0x00, 0x00, 0x1b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x0a,
	0x00, 0x02, 0x00, 0x00, 0x00, 0x61, 0x63, 0xf5, 0x62, 0x00, 0xf5, 0x00}

// 0x0 sv/: 16 cut `byte$til 32
var GuidVectorsAsBytes = []byte{0x01, 0x00, 0x00, 0x00, 0x2e, 0x00, 0x00, 0x00, 0x02, 0x00, 0x02, 0x00, 0x00, 0x00,
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13,
	0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f}

//q)-8!`a`b!2 3
var DictWithAtomsBytes = []byte{0x01, 0x00, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00,
	0x63, 0x0b, 0x00, 0x02, 0x00, 0x00, 0x00, 0x61, 0x00, 0x62, 0x00, 0x06, 0x00,
	0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00}

//-8!`a`b!enlist each 2 3
var DictWithVectorsBytes = []byte{0x01, 0x00, 0x00, 0x00, 0x2d, 0x00, 0x00, 0x00, 0x63, 0x0b, 0x00, 0x02,
	0x00, 0x00, 0x00, 0x61, 0x00, 0x62, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
	0x06, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x06, 0x00, 0x01,
	0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00}

// ([]a:enlist 2;b:enlist 3)
var TableBytes = []byte{0x01, 0x00, 0x00, 0x00, 0x2f, 0x00, 0x00, 0x00, 0x62, 0x00, 0x63, 0x0b, 0x00, 0x02,
	0x00, 0x00, 0x00, 0x61, 0x00, 0x62, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x06, 0x00, 0x01,
	0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x06, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00}

// -8!([a:enlist 2]b:enlist 3)
var KeyedTableBytes = []byte{0x01, 0x00, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x63, 0x62, 0x00, 0x63, 0x0b, 0x00, 0x01, 0x00,
	0x00, 0x00, 0x61, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x06, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02,
	0x00, 0x00, 0x00, 0x62, 0x00, 0x63, 0x0b, 0x00, 0x01, 0x00, 0x00, 0x00, 0x62, 0x00, 0x00, 0x00, 0x01, 0x00,
	0x00, 0x00, 0x06, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00}

// -8!{x+y}
var FuncBytes = []byte{0x01, 0x00, 0x00, 0x00, 0x15, 0x00, 0x00, 0x00, 0x64, 0x00, 0x0a,
	0x00, 0x05, 0x00, 0x00, 0x00, 0x7b, 0x78, 0x2b, 0x79, 0x7d}

//q)\d .d
//q.d)test:{x+y}
//q.d)-8!test
var FuncNonRootBytes = []byte{0x01, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x64, 0x64, 0x00, 0x0a,
	0x00, 0x05, 0x00, 0x00, 0x00, 0x7b, 0x78, 0x2b, 0x79, 0x7d}

var testCases = []struct {
	desc  string
	k     *K
	bytes []byte
}{
	// Mixed list
	{"(\"ac\";`b;`)", Enlist(String("ac"), Symbol("b"), Symbol("")), GenericList2Bytes},

	// Boolean
	{"0b", Bool(false), []byte{0x01, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0xff, 0x00}},
	{"01b", BoolV([]bool{false, true}), []byte{0x01, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x01}},

	// UUID
	{"8c6b8b64-6815-6084-0a3e-178401251b68", UUID(uuid.UUID{0x8c, 0x6b, 0x8b, 0x64, 0x68, 0x15, 0x60, 0x84, 0x0a, 0x3e, 0x17, 0x84, 0x01, 0x25, 0x1b, 0x68}), []byte{0x01, 0x00, 0x00, 0x00, 0x19, 0x00, 0x00, 0x00, 0xfe, 0x8c, 0x6b, 0x8b, 0x64, 0x68, 0x15, 0x60, 0x84, 0x0a, 0x3e, 0x17, 0x84, 0x01, 0x25, 0x1b, 0x68}},
	{"00010203-0405-0607-0809-0a0b0c0d0e0f 10111213-1415-1617-1819-1a1b1c1d1e1f", UUIDV([]uuid.UUID{{0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f}, {0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f}}), GuidVectorsAsBytes},

	// Byte/Uint8
	{"0x01", Byte(byte(1)), []byte{0x01, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0xfc, 0x01}},
	{"0x0102", ByteV([]byte{1, 2}), []byte{0x01, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x04, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x02}},

	// Short/Int16
	{"1h", Short(int16(1)), []byte{0x01, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0xfb, 0x01, 0x00}},
	{"1 2h", ShortV([]int16{1, 2}), []byte{0x01, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00, 0x05, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x02, 0x00}},

	// Int/Int32
	{"1i", Int(1), []byte{0x01, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x00, 0x00, 0xfa, 0x01, 0x00, 0x00, 0x00}},
	{"1 2i", IntV([]int32{1, 2}), []byte{0x01, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x06, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00}},

	// Long/Int64
	{"1j", Long(1), []byte{0x01, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0xf9, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
	{"1 2j", LongV([]int64{1, 2}), []byte{0x01, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x07, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},

	// String
	{`"GOOG"`, String("GOOG"), []byte{0x01, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x04, 0x00, 0x00, 0x00, 0x47, 0x4f, 0x4f, 0x47}},

	// Symbol
	{"`GOOG", Symbol("GOOG"), []byte{0x01, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0xf5, 0x47, 0x4f, 0x4f, 0x47, 0x00}},
	{"`abc`bc`c", SymbolV([]string{"abc", "bc", "c"}), []byte{0x01, 0x00, 0x00, 0x00, 0x17, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x03, 0x00, 0x00, 0x00, 0x61, 0x62, 0x63, 0x00, 0x62, 0x63, 0x00, 0x63, 0x00}},

	// Datetime
	{"1#2013.06.10T22:03:49.713", &K{KZ, NONE, []float64{4909.9193253819449}}, []byte{0x01, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x01, 0x00, 0x00, 0x00, 0xd6, 0x81, 0xe8, 0x58, 0xeb, 0x2d, 0xb3, 0x40}},

	// Second
	{"21:22:02 21:22:03", &K{KV, NONE, []int32{76922, 76923}}, []byte{0x01, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x12, 0x00, 0x02, 0x00, 0x00, 0x00, 0x7a, 0x2c, 0x01, 0x00, 0x7b, 0x2c, 0x01, 0x00}},

	// Minute
	{"00:00 21:22", &K{KU, NONE, []int32{0, 1282}}, []byte{0x01, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x11, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x05, 0x00, 0x00}},

	// Month
	{"2013.06 2013.07 2013.08m", &K{KM, NONE, []Month{161, 162, 163}}, []byte{0x01, 0x00, 0x00, 0x00, 0x1a, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x03, 0x00, 0x00, 0x00, 0xa1, 0x00, 0x00, 0x00, 0xa2, 0x00, 0x00, 0x00, 0xa3, 0x00, 0x00, 0x00}},

	// Timestamp
	{"2292.04.10D23:47:16.854775806", Timestamp(time.Unix(10170056836, 854775806)), []byte{0x01, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0xf4, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f}},
	{"1707.09.22D00:12:43.145224194", Timestamp(time.Unix(-8276687236, -854775806)), []byte{0x01, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0xf4, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80}},
	{"2018.01.26D01:49:00.884361000", Timestamp(TimestampAsTime), []byte{0x01, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0xf4, 0x28, 0xbf, 0xce, 0x27, 0x35, 0xec, 0xe9, 0x07}},
	{"2#2018.01.26D01:49:00.884361000", TimestampV([]time.Time{TimestampAsTime, TimestampAsTime}), []byte{0x01, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x02, 0x00, 0x00, 0x00, 0x28, 0xbf, 0xce, 0x27, 0x35, 0xec, 0xe9, 0x07, 0x28, 0xbf, 0xce, 0x27, 0x35, 0xec, 0xe9, 0x07}},

	// Date
	{"1970.01.01", Date(time.Date(1970, 1, 1, 0, 0, 0, 0, time.UTC)), []byte{0x01, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x00, 0x00, 0xf2, 0x33, 0xd5, 0xff, 0xff}},
	{"2000.01.01", Date(time.Date(2000, 1, 1, 0, 0, 0, 0, time.UTC)), []byte{0x01, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x00, 0x00, 0xf2, 0x00, 0x00, 0x00, 0x00}},
	{"2292.04.10", Date(time.Date(2292, 4, 10, 0, 0, 0, 0, time.UTC)), []byte{0x01, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x00, 0x00, 0xf2, 0xff, 0xa0, 0x01, 0x00}},
	{"1707.09.22", Date(time.Date(1707, 9, 22, 0, 0, 0, 0, time.UTC)), []byte{0x01, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x00, 0x00, 0xf2, 0x0, 0x5f, 0xfe, 0xff}},
	{"1#2013.06.10", DateV([]time.Time{time.Date(2013, 06, 10, 0, 0, 0, 0, time.UTC)}), []byte{0x01, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x01, 0x00, 0x00, 0x00, 0x2d, 0x13, 0x00, 0x00}},

	// Time
	{"23:59:59.999", Time(time.Date(1970, 1, 1, 23, 59, 59, 999000000, time.UTC)), []byte{0x01, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x00, 0x00, 0xed, 0xff, 0x5b, 0x26, 0x05}},
	{"00:00:00.000", Time(time.Date(1970, 1, 1, 0, 0, 0, 0, time.UTC)), []byte{0x01, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x00, 0x00, 0xed, 0x00, 0x00, 0x00, 0x00}},
	{"1#21:53:37.963", TimeV([]time.Time{time.Date(1970, 1, 1, 21, 53, 37, 963000000, time.UTC)}), []byte{0x01, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00, 0x13, 0x00, 0x01, 0x00, 0x00, 0x00, 0xab, 0xaa, 0xb2, 0x04}},

	// Dictionaries and tables
	{"([]a:enlist 2;b:enlist 3)", NewTable([]string{"a", "b"}, IntV([]int32{2}), IntV([]int32{3})), TableBytes},
	{"`a`b!2 3", NewDict(SymbolV([]string{"a", "b"}), IntV([]int32{2, 3})), DictWithAtomsBytes},
	{"([a:enlist 2i]b:enlist 3i)", NewDict(NewTable([]string{"a"}, IntV([]int32{2})), NewTable([]string{"b"}, IntV([]int32{3}))), KeyedTableBytes},
	{"`a`b!enlist each 2 3", NewDict(SymbolV([]string{"a", "b"}), Enlist(IntV([]int32{2}), IntV([]int32{3}))), DictWithVectorsBytes},

	// Function
	{"{x+y} in .d", NewFunc("d", "{x+y}"), FuncNonRootBytes},
	{"{x+y}", NewFunc("", "{x+y}"), FuncBytes},

	// Error
	{"'type", Error(NewRuntimeError("type")), []byte{0x01, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x80, 0x74, 0x79, 0x70, 0x65, 0x00}},
}

func TestEncoding(t *testing.T) {
	for _, tt := range testCases {
		buf := new(bytes.Buffer)
		err := Encode(buf, ASYNC, tt.k)
		if err != nil {
			t.Errorf("Encoding '%s' failed:%s", tt.desc, err)
			continue
		}
		if !bytes.Equal(buf.Bytes(), tt.bytes) {
			t.Errorf("Encoded '%s' incorrectly. Expected '%v', got '%v'\n", tt.desc, tt.bytes, buf.Bytes())
		}
	}
}

func TestEncoding_Date_NotExact(t *testing.T) {
	before1970Desc := "1969-12-31 23:59:50 +0000 UTC" // In kdb this is equivalent to `1969.12.31`
	before1970Input := Date(time.Date(1969, 12, 31, 23, 59, 50, 0, time.UTC))
	before1970Bytes := []byte{0x01, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x00, 0x00, 0xf2, 0x32, 0xd5, 0xff, 0xff}
	beforeBuf := new(bytes.Buffer)
	if err := Encode(beforeBuf, ASYNC, before1970Input); err != nil {
		t.Errorf("Encoding '%s' failed:%s", before1970Desc, err)
	} else if !bytes.Equal(beforeBuf.Bytes(), before1970Bytes) {
		t.Errorf("Encoded '%s' incorrectly. Expected '%v', got '%v'\n", before1970Desc, before1970Bytes, beforeBuf.Bytes())
	}

	after1970Desc := "1970-01-01 00:00:10 +0000 UTC" // In kdb this is equivalent to `1970.01.01`
	after1970Input := Date(time.Date(1970, 1, 1, 0, 0, 10, 0, time.UTC))
	after1970Bytes := []byte{0x01, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x00, 0x00, 0xf2, 0x33, 0xd5, 0xff, 0xff}
	afterBuf := new(bytes.Buffer)
	if err := Encode(afterBuf, ASYNC, after1970Input); err != nil {
		t.Errorf("Encoding '%s' failed:%s", after1970Desc, err)
	} else if !bytes.Equal(afterBuf.Bytes(), after1970Bytes) {
		t.Errorf("Encoded '%s' incorrectly. Expected '%v', got '%v'\n", after1970Desc, after1970Bytes, afterBuf.Bytes())
	}
}

func BenchmarkEncodeAll(b *testing.B) {
	buf := new(bytes.Buffer)
	b.ReportAllocs()

	for i := 0; i < b.N; i++ {
		for _, tt := range testCases {
			buf.Reset()
			err := Encode(buf, ASYNC, tt.k)
			if err != nil {
				b.Errorf("Encoding '%s' failed:%s", tt.desc, err)
				continue
			}
		}
	}
}
